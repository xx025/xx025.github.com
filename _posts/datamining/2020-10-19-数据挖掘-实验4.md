---
excerpt_separator: <!--more-->
---

 实验四  K近邻分析与应用
<!--more-->

![fgrfg](..\assets\img\2020-10-19\syzds.png){:height="50%" width="50%"}


数据集：
<a  href="https://github.com/xx025/xx025.github.com/tree/master/assets/file/2020-10-19">knn_data.csv</a> 
```python
import random

import numpy as np


def oppenfile():
    # 打开文件，存进数组
    # return arr[][]
    arr = np.loadtxt('knn_data.csv', dtype=float, delimiter=',')

    return np.loadtxt('knn_data.csv', dtype=float, delimiter=',')


def loadDataset(arr_, split_=0.7):
    trainingSet_ = []
    testSet_ = []
    for rol in arr_:
        if random.random() > split_:
            trainingSet_.append(rol)
        else:
            testSet_.append(rol)
    # 将近split_的数据分到训练数组组，将其余分配到验证组
    return trainingSet_, testSet_


def euclideanDistance(instance1_, instance2_, length_):
    instance1_ = instance1_[:length_]
    instance2_ = instance2_[:length_]
    # 取前-1项进行距离计算
    return np.linalg.norm(instance1_ - instance2_)


def getNeighbors(trainingSet_, testInstance_, k_=3):
    length = testInstance_.__len__() - 1
    distances_ = []
    neighbors = []
    for x in trainingSet_:
        dist = euclideanDistance(testInstance_, x, length)
        # 距离
        distances_.append((x, dist))
    distances_ = sorted(distances_, key=lambda x: x[1])
    for i in range(k_):
        neighbors.append(distances_[i][0])
    return neighbors


def getResponse(neighbors):
    classVotes = {}
    for x in range(neighbors.__len__()):
        response = neighbors[x][-1]
        if response in classVotes:
            classVotes[response] += 1
        else:
            classVotes[response] = 1
    sortedVotes = sorted(classVotes.items(), key=lambda x: x[1], reverse=True)
    # sortedVotes_2 = sorted(classVotes.items(),
    #                        key=operator.itemgetter(1), reverse=True)

    return sortedVotes[0][0]


def getAccuracy(testSet, predictions):
    correct = 0
    for x in range(testSet.__len__()):
        if testSet[x][-1] == predictions[x]:
            correct += 1
    return (correct / float(testSet.__len__())) * 100.0


def main():
    arr = oppenfile()
    trainingSet, testSet = loadDataset(arr, 0.7)
    print("trainingSet:{}".format(trainingSet.__len__()))
    print("trainingSet:{}".format(testSet.__len__()))
    predictions = list()
    for i in testSet:
        neighbors = getNeighbors(trainingSet, i, 3)
        result = getResponse(neighbors)
        predictions.append(result)
        # print('prediction={:<16}\tactual={}'.format(result, i[-1]))
        # break
    accuracy = getAccuracy(testSet, predictions)
    print('Accuracy:{}%'.format(accuracy))
    return accuracy


if __name__ == "__main__":
    lis = [main() for i in range(10)]
    i = 0
    for k in lis:
        i += k
    print(i * 1.0 / lis.__len__())

'''
精确度和两组数据量有关，多次测试(10次)输出结果如下
trainingSet:162
trainingSet:358
Accuracy:79.88826815642457%
trainingSet:147
trainingSet:373
Accuracy:81.50134048257372%
trainingSet:167
trainingSet:353
Accuracy:82.43626062322946%
trainingSet:151
trainingSet:369
Accuracy:82.11382113821138%
trainingSet:161
trainingSet:359
Accuracy:83.56545961002786%
trainingSet:142
trainingSet:378
Accuracy:79.1005291005291%
trainingSet:148
trainingSet:372
Accuracy:81.72043010752688%
trainingSet:166
trainingSet:354
Accuracy:83.61581920903954%
trainingSet:151
trainingSet:369
Accuracy:79.13279132791328%
trainingSet:145
trainingSet:375
Accuracy:78.4%
81.14747197554757
'''
```

参考代码：
![fgrfg](..\assets\img\2020-10-19\syck.png){:height="50%" width="50%"}
