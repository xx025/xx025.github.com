
- 在编写问答卷答题的过程中我发现了一个问题，就是你题库里存的问题和真正展示的问题有一些细微的差别，当然即使差别仅仅是0.0001，向列表搜索的时候依然会返回空。我就想有没有办法解决这个`模糊搜索`问题，并没有花费多少时间就找到了一个比较合适的数学工具`萊文斯坦距離(Levenshtein距離)`，通过计算字符串间的这个距离就能很容易的比对出要搜索的结果。

```
维基百科参考：
萊文斯坦距離：https://zh.m.wikipedia.org/zh-hk/萊文斯坦距離
```


```python
# @File    : englishwords.py
lis = ['', 'settle', 'oppose', 'mood', 'craftsman',
            'agitate', 'catholic', 'go-ahe', 'bribery',
            'emphasize']
```

👆这儿的列表只列了列表`lis=..`的部分,完整的文件(一些英语单词)：
<a  href="https://github.com/xx025/xx025.github.com/blob/master/assets/file/2020-10-16/englishwords.py">englishwords.py</a>  

```python
# @File    : main.py
import Levenshtein
import englishwords

lis = englishwords.lis


def fuzzysearch(str_, lis_):
    lis = [Levenshtein.distance(str_, i) for i in lis_]
    # 分别计算莱文斯坦距离（Levenshtein）
    return lis_[lis.index(min(lis))]
    # 返回列表中莱文斯距离的最小值的字符串


print(fuzzysearch('directy', lis))
print(fuzzysearch('dieooooooocty', lis))
```
```
输出：
directly
discomfort
```


除上面外我还想到了其他两点:

1. 在你给定字符串`str`后一般你想要的结果`r_str`应该有一定的长度限制，如
    ```
    |len(r_str)-len(str)|<len(str)*125%
    ```
2. 计算的莱文斯距离也应该存在一个上限,如
    ```
    Levenshtein.distance(str_, i)<=len(str)*25%
    ```
    
